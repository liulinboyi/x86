# 段间直接绝对跳转指令

这是一个完整的主引导扇区内容，在处理器加电或者复位之后，先执行ROM-bios，ROM-bios做完他的工作之后，把主引导扇区，读到内存的物理地址0x7c00处，然后开始执行读取的指令，第一条指令在物理地址0x7c00处。

物理地址0x7c00的逻辑地址可以表示成 0x0000:0x7c00

jmp  0x0000:0x7c00

表示跳转指令

这条指令将导致处理器，重新执行从主引导扇区读到内存的指令，然后循环



指令（段间直接绝对跳转指令）构成

jum 逻辑地址（段地址:偏移地址）

jmp 段地址:偏移地址

其中

段间表示，跳到另一个段中执行，这条指令会用指令中的段地址修改代码段寄存器cs，用指令中的偏移地址修改指令指针寄存器ip，因为修改了这两个寄存器，所以处理器会跳到新的段中去执行，所以称为段间跳转。

直接绝对表示跳转的位置，是直接给出的不需要计算。

```
start:
        mov ax, 0xb800 ;把0xb800传给通用寄存器ax 这句指令中，目的操作数：ax寄存器长度是16位的 ，源操作数：0xb800也是16位的长度 所以这条指令按照16位长度进行，不存起歧义

        ;目的操作数：ds寄存器长度是16位的 ，源操作数：ax寄存器也是16位的长度 所以这条指令按照16位长度进行，不存起歧义
        mov ds, ax     ;把通用寄存器ax的内容传送给ds数据段寄存器，英特尔处理器，不允许，将一个立即数，存到段寄存器，只能用通用寄存器中转
        ;因为有立即数，为了访问内存单元，需要给出段地址和偏移地址

        ;操作数部分0x41可以理解为一个字节也可以理解为一个字（两个字节）
        ;内存操作数部分，只是制定一个起始的偏移地址，没有其他信息，起始地址可以使一个字节，也可以是一个字的起始地址
        ;两个操作数的长度都很模糊，mov指令无法确定是以字节进行或者以字（两个字节）进行，所以必须使用byte来修饰目的操作数
        ;指出，[0x00]是一个字节单元的操作地址，本次传送是以字节的方式进行，
        ;一旦目的操作数，被指明是字节（byte），那么源操作数0x41，理所应当是一个byte（字节）长
        mov byte [0x00],byte 0x41      ;字符A的ASCII编码     偏移地址0x00，段地址如果没有其他任何指示，在ds段寄存器中0xb800
        mov byte [0x01], 0x04      ;黑底红字，无闪烁

        mov byte [0x02], 's'       ;等同于 mov byte [0x02], 0x73 其中's'是字符的字面值
        mov byte [0x03], 0x04

        mov byte [0x04], 's'
        mov byte [0x05], 0x04

        mov byte [0x06], 'e'
        mov byte [0x07], 0x04

        mov byte [0x08], 'm'
        mov byte [0x09], 0x04

        mov byte [0x0a], 'b'
        mov byte [0x0b], 0x04

        mov byte [0x0c], 'l'
        mov byte [0x0d], 0x04

        mov byte [0x0e], 'y'
        mov byte [0x0f], 0x04

        mov byte [0x10], '.'
        mov byte [0x11], 0x04

        ;mov [0xb8012], 'h'     ;编译失败，这里[]只能使用偏移量
        ;mov [0xb8013], 0x04

        ;mov byte [0x12], 'h'
        ;mov byte [0x13], 0x04
        jmp 0x0000:0x7c00   ;主引导扇区，第一条指令在物理地址0x7c00处
current:
        times 510 - (current - start) db 0

        db 0x55, 0xAA
```

